---
import { sanityClient, urlFor } from '../lib/sanity';
import type { InspiredArtist } from '../types/sanity';

const inspiredArtists = await sanityClient.fetch<InspiredArtist[]>(
  `*[_type == "inspiredArtist"] | order(_createdAt desc) {
    _id,
    name,
    slug,
    profileImage
  }`
);
---

<section class="py-10 md:py-20 overflow-hidden bg-black">
  <div class="text-center">
    <h2 class="h2 mb-10 md:mb-20">//echoes</h2>
  </div>

  <div class="echoes-carousel" id="echoes-carousel">
    <div class="echoes-track">
      {inspiredArtists.map((artist, index) => (
        <a 
          href={`/echoes/${artist.slug.current}`}
          class="echoes-card"
        >
          <img
            src={urlFor(artist.profileImage).width(400).height(400).url()}
            alt={artist.name}
            class="echoes-image"
          />
        </a>
      ))}
    </div>
  </div>

  <div class="flex justify-end mt-24 pr-4">
    <div class="max-w-xs md:max-w-sm text-right mr-20">
      <p class="p" style="color: var(--color-muted)">
        a collection of voices that echoed through <span class="text-brand-secondary">{"{void}"}</span> to spark inspiration.
      </p>
    </div>
  </div>
</section>

<script>
  // Infinite marquee that only moves when the page is scrolled
  const carousel = document.getElementById('echoes-carousel');
  const track = carousel?.querySelector('.echoes-track') as HTMLElement | null;
  if (carousel && track) {
    const scroller = carousel as HTMLDivElement;
    // 1) Duplicate the track's children to enable seamless wrap-around
    const segmentCount = 3; // number of repeated segments in the track
    const originalChildren = Array.from(track.children);
    for (let i = 1; i < segmentCount; i++) {
      for (const child of originalChildren) {
        track.appendChild(child.cloneNode(true));
      }
    }

    // 2) Keep track of a single segment width to wrap scrollLeft
    let segmentWidth = 0;
    const computeSegmentWidth = () => {
      // Defer until images/layout settle
      segmentWidth = track.scrollWidth / segmentCount;
    };
    window.addEventListener('load', computeSegmentWidth);
    window.addEventListener('resize', computeSegmentWidth);
    // Compute once immediately as well
    computeSegmentWidth();

    // 3) Move horizontally only while the user is scrolling the page
    let lastScrollY = window.scrollY;
    const speedFactor = 0.6 // even slower for smoother feel
    let isDragging = false;
    let lastDragEndAtMs = 0;
    const DRAG_COOLDOWN_MS = 200; // longer cooldown for smoother transitions
    let targetScrollLeft = 0;
    let currentScrollLeft = 0;
    let animationFrameId: number | null = null;

    function smoothScrollToTarget() {
      const diff = targetScrollLeft - currentScrollLeft;
      if (Math.abs(diff) < 0.1) {
        currentScrollLeft = targetScrollLeft;
        scroller.scrollLeft = currentScrollLeft;
        return;
      }
      
      // Smooth interpolation with easing
      currentScrollLeft += diff * 0.08; // Adjust this value for smoother/faster animation
      scroller.scrollLeft = currentScrollLeft;
      
      // Seamless wrap-around
      if (segmentWidth > 0) {
        if (currentScrollLeft >= segmentWidth) {
          currentScrollLeft -= segmentWidth;
          targetScrollLeft -= segmentWidth;
        } else if (currentScrollLeft < 0) {
          currentScrollLeft += segmentWidth;
          targetScrollLeft += segmentWidth;
        }
      }
      
      animationFrameId = requestAnimationFrame(smoothScrollToTarget);
    }

    function onPageScroll() {
      const currentY = window.scrollY;
      // Do not auto-move while user is dragging or right after dragging
      if (isDragging || (Date.now() - lastDragEndAtMs) < DRAG_COOLDOWN_MS) {
        lastScrollY = currentY;
        return;
      }
      const deltaY = currentY - lastScrollY;
      lastScrollY = currentY;
      if (deltaY === 0) return; // do nothing when not scrolling

      // Down -> content moves left (increase scrollLeft)
      // Up   -> content moves right (decrease scrollLeft)
      targetScrollLeft += deltaY * speedFactor;

      // Start smooth animation if not already running
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(smoothScrollToTarget);
      }
    }

    window.addEventListener('scroll', onPageScroll, { passive: true });

    // 4) Optional: retain mouse drag to manually explore content
    let startX: number;
    let initialScrollLeft: number;

    scroller.addEventListener('mousedown', (e) => {
      isDragging = true;
      scroller.classList.add('dragging');
      startX = e.pageX - scroller.offsetLeft;
      initialScrollLeft = currentScrollLeft;
      // Cancel smooth animation during drag
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    scroller.addEventListener('mouseleave', () => {
      isDragging = false;
      lastDragEndAtMs = Date.now();
      scroller.classList.remove('dragging');
    });

    scroller.addEventListener('mouseup', () => {
      isDragging = false;
      lastDragEndAtMs = Date.now();
      scroller.classList.remove('dragging');
    });

    scroller.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const x = e.pageX - scroller.offsetLeft;
      const walk = (x - startX) * 2;
      currentScrollLeft = initialScrollLeft - walk;
      scroller.scrollLeft = currentScrollLeft;

      // Keep wrap-around working during drag as well
      if (segmentWidth > 0) {
        if (currentScrollLeft >= segmentWidth) {
          currentScrollLeft -= segmentWidth;
          scroller.scrollLeft = currentScrollLeft;
        } else if (currentScrollLeft < 0) {
          currentScrollLeft += segmentWidth;
          scroller.scrollLeft = currentScrollLeft;
        }
      }
    });
  }
</script>

<style>
  .echoes-carousel {
    overflow-x: auto;
    overflow-y: hidden;
    cursor: grab;
    user-select: none;
    padding: 2rem 1rem;
    scroll-behavior: auto;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
  }

  .echoes-carousel.dragging {
    cursor: grabbing;
    scroll-behavior: auto;
  }

  .echoes-carousel::-webkit-scrollbar {
    display: none;
  }

  .echoes-track {
    display: flex;
    gap: 1.5rem;
    width: max-content;
  }

  .echoes-card {
    display: block;
    width: 300px;
    height: 400px;
    transform: rotate(0deg);
    transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.5s cubic-bezier(0.22, 1, 0.36, 1);
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
    transform-origin: center;
    transform-style: preserve-3d;
    will-change: transform, box-shadow;
    border-width: 4px;
    border-style: solid;
    border-color: #a8a29e; /* stone-400 */
  }

  .echoes-card:hover {
    transform: rotate(0deg) translateY(-8px) scale(1.04);
    z-index: 10;
  }

  .echoes-card:focus-visible {
    outline: none;
  }

  .echoes-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    filter: grayscale(100%) sepia(100%) hue-rotate(180deg) saturate(200%);
    transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), filter 0.6s cubic-bezier(0.22, 1, 0.36, 1);
    will-change: transform;
    box-sizing: border-box;
  }

  .echoes-card:hover .echoes-image,
  .echoes-card:focus-visible .echoes-image {
    transform: scale(1.06);
    filter: none;
  }

  .echoes-card::before {
    content: '';
    position: absolute;
    pointer-events: none;
  }

  .echoes-card::after {
    content: '';
    position: absolute;
    opacity: 0;
    transform: translateY(6px);
    transition: opacity 0.5s ease, transform 0.5s ease;
    pointer-events: none;
    border-width: 4px;
    border-style: solid;
    border-color: #a8a29e; /* stone-400 */
  }

  .echoes-card:hover::after,
  .echoes-card:focus-visible::after {
    opacity: 1;
    transform: translateY(0);
  }
</style>
